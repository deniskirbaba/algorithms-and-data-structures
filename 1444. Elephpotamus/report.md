#### <div align="center"> [Задача 1444. Накормить элефпотама](https://acm.timus.ru/problem.aspx?space=1&num=1444) </div>

>Ограничение времени: 0.5 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Гарри Поттер сдаёт экзамен по предмету «Уход за магическими существами». Его задание — накормить карликового элефпотама. Гарри помнит, что элефпотамы отличаются прямолинейностью и невозмутимостью. Они настолько прямолинейны, что ходят строго по прямой, и настолько невозмутимы, что заставить их идти можно, только если привлечь его внимание к чему-нибудь действительно вкусному. И главное, наткнувшись на цепочку своих собственных следов, элефпотам впадает в ступор и отказывается идти куда-либо. По словам Хагрида, элефпотамы обычно возвращаются домой, идя в обратную сторону по своим собственным следам. Поэтому они никогда не пересекают их, иначе могут заблудиться. Увидев свои следы, элефпотам детально вспоминает все свои перемещения от выхода из дома (поэтому-то они и ходят только по прямой и лишний раз не меняют направление — так легче запоминать). По этой информации элефпотам вычисляет, в какой стороне расположена его нора, после чего поворачивается и идет прямо к ней. Эти вычисления занимают у элефпотама некоторое (довольно большое) время. А то, что некоторые невежды принимают за ступор, на самом деле есть проявление выдающихся вычислительных способностей этого чудесного, хотя и медленно соображающего животного!
>
> Любимое лакомство элефпотамов — слоновьи тыквы, именно они и растут на лужайке, где Гарри должен сдавать экзамен. Перед началом испытания Хагрид притащит животное к одной из тыкв. Скормив элефпотаму очередную тыкву, Гарри может направить его в сторону любой оставшейся тыквы. Чтобы сдать экзамен, надо провести элефпотама по лужайке так, чтобы тот съел как можно больше тыкв до того, как наткнется на свои следы.

###### Исходные данные:

> В первой строке входа находится число *N* (3 ≤ *N* ≤ 30000) — количество тыкв на лужайке. Тыквы пронумерованы от 1 до *N*, причем номер один присвоен той тыкве, у которой будет стоять элефпотам в начале экзамена. В следующих *N* строках даны координаты всех тыкв по порядку. Все координаты — целые числа от −1000 до 1000. Известно, что положения всех тыкв различны, и не существует прямой, проходящей сразу через все тыквы.

###### Результат:

> В первой строке выхода вы должны вывести *K* — максимальное количество тыкв, которое может съесть элефпотам. Далее по одному числу в строке выведите *K* чисел — номера тыкв в порядке их обхода. Первым в этой последовательности всегда должно быть число 1.

| Исходные данные           | Результат |
|---------------------------|-----------|
| `4`                       | `4`       |
| `0 0`                     | `1`       |
| `10 10`                   | `3`       |
| `0 10`                    | `2`       |
| `10 0`                    | `4`       |

###### Описание алгоритма:

> Координаты первой тыквы определяет начало координат в новой системе отсчета.  
> Вычисляется угол относительно оси Ох и расстояние до начала координат для каждой последующей тыквы.  
> Затем тыквы сортируются по углу и по расстоянию от начала координат.  
> Далее находится максимальный угол между направлениями на две соседние точки, чтобы найти начало обхода, исключающее пересечение с маршрутом 2 соседних точек.  
> В конце всех операций выводится обход точек с точки входа.  

###### Реализация:

```cpp
#include <iostream>
#include <cmath>

using std::cin, std::qsort, std::cout;

#define PI 3.14159265;

struct pumpkin {
    uint32_t d; // distance from the origin
    double ang; // angle from the origin
    uint16_t id;

    void create(int16_t x0, int16_t y0, uint16_t index) {
        int16_t x, y;
        cin >> x >> y;
        this->id = index + 1;
        this->d = (x - x0) * (x - x0) + (y - y0) * (y - y0);
        this->ang = atan2(y - y0, x - x0) * 180.0 / PI;
        if (y - y0 < 0) this->ang += 360; // make all angles positive
    }
};

int compare(const void *a, const void *b) {
    const pumpkin *p1 = (pumpkin*) a;
    const pumpkin *p2 = (pumpkin*) b;
    if (p1->ang - p2->ang > 1e-10) return 1; // angle is 1 priority
    else if (p1->ang - p2->ang < -1e-10) return -1;
    else if (p1->d > p2->d) return 1; // distance is 2 priority
    else return -1;
}

int main() {
    uint16_t n;
    int16_t x0, y0; // origin
    cin >> n >> x0 >> y0;
    pumpkin field[n];
    field[0] = (pumpkin){0, -1,1}; // for avoiding error while sort
    for (uint16_t i = 1; i < n; i++) field[i].create(x0, y0, i);

    qsort(field, n, sizeof(pumpkin), compare);

    uint16_t start = 1;
    for (uint16_t i = 1; i < n - 1; i++) // if an angle > 180 - path crossing
        if (field[i + 1].ang - field[i].ang > 179.999) start = i + 1;

    cout << n << '\n' << 1 << '\n';

    for (uint16_t i = start; i < n; i++) cout << field[i].id << '\n';
    for (uint16_t i = 1; i < start; i++) cout << field[i].id << '\n';

    return 0;
}
```

###### Подтверждение выполнения:

