#### <div align="center"> [Задача 2025. Стенка на стенку](https://acm.timus.ru/problem.aspx?space=1&num=2025) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Бокс, каратэ, самбо… Классические боевые единоборства пресытили аудиторию. Поэтому известный спортивный канал запускает новый формат соревнований, основанный на традиционной русской забаве — боях стенка на стенку. В соревновании могут участвовать от двух до k команд, каждая из которых будет соперничать с остальными. Всего в соревновании примут участие n бойцов. Перед началом боя они должны разделиться на команды, каждый боец должен войти ровно в одну команду. За время боя два бойца сразятся, если они состоят в разных командах. Организаторы считают, что популярность соревнований будет тем выше, чем больше будет количество схваток между бойцами. Помогите распределить бойцов по командам так, чтобы максимизировать количество схваток между бойцами, и выведите это количество

###### Исходные данные:

> В первой строке дано количество тестов T (1 ≤ T ≤ 10). В следующих T строках перечислены тесты. В каждой из них записаны целые числа n и k через пробел (2 ≤ k ≤ n ≤ 10^4)

###### Результат:

> Для каждого теста в отдельной строке выведите одно целое число — ответ на задачу

| Исходные данные  | Результат |
| ---------------- | --------- |
| `3 6 3 5 5 4 2 ` | `12 10 4` |

###### Описание алгоритма:

> Для того чтобы найти максимальное возможное количество взаимодействия каждого участника одной группы со всеми участниками всех остальных групп нужно максимально равномерно распределить бойцов по командам. То есть сделать команды по численности максимально равными. В используемом алгоритме если количество участников кратно количеству команд, то распределяем их поровну, иначе распределяем избыток участников по одному в уже существующие комманды. Количество возможных взаимодействий рассчитывается в двух циклах *for*. В первом считаются схватки маленьких команд с маленькими и маленьких с большими, а во втором больших с большими. Чтобы предотвратить учет уже прошедших схваток на каждой итерации уменьшается количество команд и бойцов.

###### Реализация:

```cpp
#include <iostream>

int main() {

    //input of the number of tests
    int tests;
    std::cin >> tests;

    for (int i = 0; i < tests; i++) { // for each new test, perform actions

        // data input
        int fighters;
        std::cin >> fighters;
        int commands;
        std::cin >> commands;

        int fighters_in_small_team = fighters / commands; // number of the fighters in small teams
        int fighters_in_big_team = fighters_in_small_team + 1;
        int number_of_big_teams = fighters %
                                  commands; // big team = small team + 1 fighter (from those who need to be distributed one by one to teams)
        int fights = 0;

        for (; commands > number_of_big_teams; commands--) { // fights += (small team vs small team) + (small team vs big team)
            fighters -= fighters_in_small_team;
            fights += fighters_in_small_team * fighters;
        }

        for (; commands > 1; commands--) { // fights += (big team vs big team)
            fighters -= fighters_in_big_team;
            fights += fighters_in_big_team * fighters;
        }

        // output the result
        std::cout << fights << std::endl;
    }

    return 0;
}

```

###### Подтверждение выполнения:
![image](https://user-images.githubusercontent.com/75897943/157514162-5527c4a0-8a0f-4643-a499-3f16f064658f.png)
